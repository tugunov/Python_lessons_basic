# Задание-1:
# Матрицы в питоне реализуются в виде вложенных списков:
# Пример. Дано:
matrix = [[1, 0, 8],
          [3, 4, 1],
          [0, 4, 2]]
          
# Выполнить поворот (транспонирование) матрицы
# Пример. Результат:
# matrix_rotate = [[1, 3, 0],
#                  [0, 4, 4],
#                  [8, 1, 2]]

# Суть сложности hard: Решите задачу в одну строку

print(list(map(list, zip(*matrix)))) # решение в одну строчку для любителей олимпиад

# но так как это было в методичке, надо разобраться, как эта строка работает

print(*matrix)

# [1, 0, 8] [3, 4, 1] [0, 4, 2]
# непонятно, какой объект, дает * кортеж или просто последовательность
# print(type(*matrix))
# Traceback (most recent call last):
#   File "/Users/alexandertugunov/geekbrains/test.py", line 21, in <module>
#     print(type(*matrix))
# TypeError: type.__new__() argument 1 must be str, not list
# далее
print(list(zip([1, 0, 8], [3, 4, 1], [0, 4, 2]))) # как работает zip - понятно

# [(1, 3, 0), (0, 4, 4), (8, 1, 2)]

print(list(map(list, zip([1, 0, 8], [3, 4, 1], [0, 4, 2])))) 
# это действие - чтобы сделать списки из кортежей
# [[1, 3, 0], [0, 4, 4], [8, 1, 2]]

matrixT = list(map(list, zip(*matrix))) # красивый вывод матрицы для нормальных людей
for line in matrixT:
       print(line)

# Задание-2:
# Найдите наибольшее произведение пяти последовательных цифр в 1000-значном числе.
# Выведите произведение и индекс смещения первого числа последовательных 5-ти цифр.
# Пример 1000-значного числа:
number = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450"""

def maxproduct(number):
    # на вход - строка с числом
    # на выход - кортеж из произведения и индекса смещения
    number = number.replace('\n', '') # удаляем символы перевода строки

    max_product = 0
    pointer = 0 # инициализируем индекс смещения
    for i, el in enumerate(number[:len(number)-5]): 
    # заканчиваем за 5 символов до конца строки, чтобы не было IndexError
        product = 1
        for j, item in enumerate(number[i:i+5]):
            product = product * int(item)
        if product > max_product:
            max_product = product
            pointer = i
    return max_product, pointer

result = maxproduct(number)
print('Максимальное произведение: {} Индекс смещения: {} Подстрока: {}'\
    .format(result[0], result[1], number.replace('\n', '')[result[1]:result[1]+5]))

# Задание-3 (Ферзи):
# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били
# друг друга. Вам дана расстановка 8 ферзей на доске.
# Определите, есть ли среди них пара бьющих друг друга.
# Программа получает на вход восемь пар чисел,
# каждое число от 1 до 8 — координаты 8 ферзей.
# Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.

# Математическая формулировка задачи расстановки ферзей:
'''Заполнить матрицу размером 8×8 нулями и единицами таким образом, 
чтобы сумма всех элементов матрицы была равна 8, при этом сумма элементов 
ни в одном столбце, строке или диагональном ряде матрицы не превышала единицы'''

# координаты для простоты как в матрице - строка, столбец (сверху вниз, слева направо)


def mtx_sum(mtx):
	# на вход квадратная матрица
	# на выход - суммы строк, столбцов и диагоналей в виде кортежа четырех списков

    # условие строки: i = k, k = [0, 7] (математическая запись)
    # условие столбца: j = k, k = [0, 7]
    # условие диагоналей, параллельных главной диагонали матрицы:
    # i - j = k, k = [-6, 6] - угловые клетки не считаются диагоналями
    # таких диагоналей 13 штук
    # условие обратных диагоналей:
    # i + j = k, k = [1, 13]

    # для учета сумм создаем списки
    lines = [0 for el in range(0, 8)] # cуммы строк
    columns = [0 for el in range(0, 8)] # суммы столбцов
    diag = [0 for el in range(0, 13)] # суммы диагоналей, параллельных главной
    # порядок перечисления диагоналей матрицы в списке справа налево, сверху вниз
    rdiag = [0 for el in range(0, 13)] # суммы диагоналей, параллельных 
    # порядок перечисления диагоналей матрицы в списке слева направо, сверху вниз

    for i, line in enumerate(mtx):
        for j, col in enumerate(line):
            lines[i] += col
            columns[j] += col
            for k in range(0, 13):
                if i - j == k - 6:
                    diag[k] += col
                if i + j == k + 1:
                    rdiag[k] += col
    return lines, columns, diag, rdiag

def queen(crd):
    # на вход получаем список кортежей с координатами ферзей
    # координаты от 1 до 8 по каждому измерению
    # на выход True - если это решение задачи, False - если нет


    # создаем нулевую матрицу
    mtx = [[0 for el in range(0, 8)] for el in range(0,8)]
    
    for el in crd: # пишем в нее координаты фигур, полученные на вход
        for i, line in enumerate(mtx):
            for j, col in enumerate(line):
                if (i, j) == (el[0]-1, el[1]-1): # преобразование в матричные координаты
                    mtx[i][j] = 1 # означает положение ферзя
    
    for line in mtx:
        print(line) # контрольная печать матрицы для проверки
    
    for lst in mtx_sum(mtx):
        for item in lst:
            if item > 1:
                return False
    return True # сюда не дойдет, если хотя бы одна сумма больше единицы
            

lst = ((1, 1), (2,2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8))
# диагональная матрица с единицами на главной диагонали - не будет решением задачи
if queen(lst):
    print('YES')
else:
    print('NO')